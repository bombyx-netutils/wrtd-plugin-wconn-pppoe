#!/usr/bin/python3
# -*- coding: utf-8; tab-width: 4; indent-tabs-mode: t -*-

import os
import sys
import time
import shutil
import subprocess
import multiprocessing
from wrt_util import NewMountNamespace


def get_plugin_list(self):
    return [
        "gwbn-4m",             # 长城宽带4M
    ]


def get_plugin(self, name):
    if name == "gwbn":
        return _PluginObject(4 * 1024 * 1024 / 8)
    else:
        assert False


class _PluginObject:

    def __init__(self, bandwidth):
        self.bandwidth = bandwidth

    def init2(self, cfg, tmpDir, ownResolvConf):
        self.cfg = cfg
        self.tmpDir = tmpDir
        self.ownResolvConf = ownResolvConf

    def start(self):
        subprocess.check_output(["/bin/ifconfig", self.cfg["interface"], "up"])

        if "username" in self.cfg:
            username = self.cfg["username"]
        else:
            username = ""
        if "password" in self.cfg:
            password = self.cfg["password"]
        else:
            password = ""

        self.proc = multiprocessing.Process(target=self._subprocPppoe,
                                            args=("", self.cfg["interface"], username, password, ))
        self.proc.start()

        while not os.path.exists(os.path.join(self.tmpDir, "etc-ppp", "resolv.conf")):
            time.sleep(1.0)

    def stop(self):
        if self.proc is not None:
            self.proc.terminate()
            self.proc.join()
            self.proc = None

    def getOutInterface(self):
        return "wrt-ppp-wan"

    def _subprocPppoe(self, optionTemplate, interface, username, password):
        tmpEtcPppDir = os.path.join(self.tmpDir, "etc-ppp")
        tmpPapSecretsFile = os.path.join(tmpEtcPppDir, "pap-secrets")
        tmpIpUpScript = os.path.join(tmpEtcPppDir, "ip-up")
        tmpIpDownScript = os.path.join(tmpEtcPppDir, "ip-down")
        tmpPeerFile = os.path.join(tmpEtcPppDir, "peers", "wan")
        proc = None

        try:
            os.mkdir(tmpEtcPppDir)

            with open(tmpPapSecretsFile, "w") as f:
                buf = ""
                buf += "%s wan \"%s\" *\n" % (username, password)
                f.write(buf)
            os.chmod(0o600, tmpPapSecretsFile)

            with open(tmpIpUpScript, "w") as f:
                buf = ""
                buf += "#!/bin/sh\n"
                buf += "\n"
                buf += "echo \"# Generated by fpemud-wrt\" > %s\n" % (self.ownResolvConf)
                buf += "[ -n \"$DNS1\" ] && echo \"nameserver $DNS1\" >> %s\n" % (self.ownResolvConf)
                buf += "[ -n \"$DNS2\" ] && echo \"nameserver $DNS2\" >> %s\n" % (self.ownResolvConf)
                f.write(buf)
            os.chmod(0o755, tmpPapSecretsFile)

            os.chmod(0o755, tmpIpUpScript)

            with open(tmpIpDownScript, "w") as f:
                buf = ""
                buf += "#!/bin/sh\n"
                buf += "\n"
                buf += "echo \"\" > %s\n" % (self.ownResolvConf)
            os.chmod(0o755, tmpIpDownScript)

            os.mkdir(os.path.dirname(tmpPeerFile))
            with open(tmpPeerFile, "w") as f:
                buf = optionTemplate.replace("$USERNAME", username)
                buf += "\n"
                buf += "pty \"pppoe -I %s\"\n" % (interface)
                buf += "lock\n"
                buf += "noauth\n"
                buf += "ifname wrt-ppp-wan\n"
                buf += "persist\n"
                buf += "holdoff 10\n"
                buf += "defaultroute\n"
                buf += "usepeerdns\n"
                buf += "remotename wan\n"
                buf += "user %s\n" % (username)
                f.write(buf)

            with NewMountNamespace():
                # pppd read config files from the fixed location /etc/ppp
                # this behavior is bad so we use mount namespace to workaround it
                subprocess.check_output(["/bin/mount", "--bind", tmpEtcPppDir, "/etc/ppp"])
                cmd = "/usr/sbin/pppd call wan nodetach"
                proc = subprocess.Popen(cmd, shell=True, universal_newlines=True)
                proc.wait()
        finally:
            if os.path.exists(tmpEtcPppDir):
                shutil.rmtree(tmpEtcPppDir)
            if proc is not None:
                sys.exit(proc.returncode)
